1、解析Cocosd-x中的智能指针
	cocos2dx中所有内存管理方式的基础是引用计数，动态分配一个Ref对象后
其引用计数为1，并通过retain和release来增持和减少其引用计数。引用计数
本身并不能帮助我们进行内存管理。
	使用自动回收池的机制来管理对象内存的释放
	autorelease有点儿类似于一个共享的智能指针，该智能指针的作用域为一帧，
该帧结束后，它将释放自己的引用计数，此时，如果该对象没有被其他的共享指针引用，
则对象被释放。如果对象被引用，则保留。
	Vector和Map<K,V>通常用来和autorelease一起工作，通常应该将一个autorelease对象
加入到Vector或者map中，例如node将所有的子元素存储在一个Vector<Node*>中。Vector和
Map对新加入的元素执行retain操作中，并对从中移除的元素执行release操作，这样元素在
从vector或者map中移除的时候就会被自动释放。
	对于单个的非集合元素对象，我们往往不会通过autorelease来进行管理，除非它是一个
临时对象。这个时候我们只能手动使用retain和release来进行管理，这其实等价于new和delete
来进行内存管理，这样的情况就容易导致内存管理问题。
	3.1中加入了智能指针RefPtr，RefPtr是基于RALL[引用6]实现的，RALL是管理动态内存
的方法。在Rall中，动态资源的持有发生在一个对象的生命周期之内，即是说在对象的构造
函数中分配内存，在对象的析构函数中释放内存。这就是将动态分配的内存映射到一个自动
变量上，通过自动变量的构造函数和析构函数来分配和释放内存。这样可以保证资源始终会
被释放，即使出现异常，也能被正常释放。这也是智能指针如std::shared_ptr实现的基本原理。
	RefPtr实际上是模仿C++11的std::shared_ptr是实现的，它保持着一个Ref*对象的强引用，
并使用cocos2d-x自身的引用计数来管理多个智能指针对内存的共享。
	1.1构造函数
	RefPtr需要依赖于Ref的引用计数来管理内存，所有类型T必须是一个Ref类型，cocos2dx通过
静态转换static_const来在编译时进行类型检查。
	RefPtr提供了几个重载的构造函数，由于RefPtr变量和Ref指针是一种强引用关系，所以这些
构造函数会对任何不为nullptr的Ref指针增持其引用计数，除非它是一个右值。
	1.2赋值操作符
	与构造函数类似，任何左值变量的赋值，Refptr都应该与该左值共享资源而增持其引用计数，
而对于右值，仍然应该使用转移而不是共享。与构造函数不同的是，赋值操作符除了会增持其资源
引用计数，还会释放对之前旧的资源的引用计数。
	1.3弱引用赋值
	不管是复制构造函数，还是赋值操作符，RefPtr会对任何非空的左值的资源保持一种强引用的
关系。而有时候对于左值的资源我们仍然可能希望保持一种弱引用的关系。
UI元素都需要使用autorelease来管理，而游戏中的数据则使用智能指针RefPtr
2、C++显示堆内存管理
	C++使用new关键字在运行时给一个对象动态分配内存，并返回堆上内存的地址供应用程序访问，
通过动态分配的内存需要在对象不再被使用时通过delete运算符将其内存归还给内存池
	不能正确处理堆内存的分配与释放通常会导致以下一些问题：
	野指针：指针指向的内存单元已经被释放，但是其他的一些指针可能还指向它，这些内存可能
已经被重新分配给其他对象，从而导致不可预测的结果。
	重复释放：重复释放一个已经被释放的内存单元，或者释放一个野指针（也是重复释放）都会
导致C++运行时错误。
	内存泄露：不再被使用的内存单元如果不被释放就会一直占用内存单元，如果这些操作不断重复
就会导致内存占用不断增加，在游戏中内存泄露尤其严重，因为可能每一帧都在创建一个永远不会被
回收的游戏对象。
3、C++11中的智能指针
	
